面向对象中，子类继承(Inherit)父类，减免重复的行为定义，不过并非为了避免重复就使用继承。
如何正确判断使用继承的时机，以及继承之后如何活用多态，才是学习继承时的重点。

static成员是属于类的，不能被继承，其他成员(包括private)都会被继承

子类只能继承一个父类，子类与父类之间会有is-a的关系，如果定义对象时，右边类is a左边类，编译就能通，如：
	Role role = new SwordsMan();

多态：使用单一接口操作多种类型的对象。

权限关键字与范围 权限依次减小
关键字     | 类内部 | 相同包类 | 不同包类
----------|-------|--------|-------
public    |   √   |   √    |   √
protected |   √   |   √    | 子类可存取
default   |   √   |   √    |   ×
private   |   √   |   ×    |   ×

子类如果想取得父类中的方法定义，可以在调用方法前，加上super关键字
重新定义父类中的方法时，方法权限只能扩大，不能缩小。

如果类有继承关系，在创建子类实例后，会先进行父类定义的初始流程，再进行子类中定义的初始流程，也就是说，会先执行父类构造函数定义的流程，再执行子类构造函数定义的流程。
构造函数可以重载，父类中可重载多个构造函数，如果子类构造函数中没有指定执行父类中哪个构造函数，会调用父类中无参数构造函数。
**特别注意**：this()与super()只能择一调用，而且一定要在构造函数的第一行执行
**特别注意**：如果没有撰写任何构造函数，编译程序会自动加入没有参数的默认构造函数(Default constructor)，如果定义了任一构造函数，系统就不会自动加入任何构造函数。

class前可以加final关键字，如果class前使用了final关键字定义，那么表示这个类是最终类，不会再有子类，也不能被继承。
定义方法是也可以限定该方法为final，这表示最后一次定义，子类不可重新定义final。

如果定义类时，没有指定父类，则默认继承自java.lang.Object，只要不是被定义为final的方法，都可以重新定义。
许多方法若传入对象，默认都会调用toString()方法，例如，System.out.print()

**instanceof**运算符可以用来判断对象是否由某个类或者其子类创建

JVM的垃圾收集(Garbage Collection, GC)机制：执行流程中，无法通过变量参考的的对象就是GC认定的垃圾对象。